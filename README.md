# AndroidHAL Simulator (Basic Implementation)

This repository contains a minimal end‑to‑end Android HAL style simulator :

- C++ HAL module that simulates camera and audio sensor interfaces
- V4L2‑style abstraction layer for camera frames
- Java framework class that talks to the HAL through JNI
- A shape that resembles AOSP HIDL/AIDL and Binder boundaries, but implemented in a desktop‑friendly way

The goal is to demonstrate the concepts in the simplest possible way, not to build a production Android HAL or to depend on a full AOSP tree.

---

## Repository layout

- `cpp/AndroidHal.h`, `cpp/AndroidHal.cpp`
  - C++ HAL implementation for camera and audio
  - Contains the V4L2‑style abstraction and simple audio level source
- `cpp/JniBridge.cpp`
  - C++ JNI bridge that exposes the HAL as native methods
- `java/com/example/androidhal/HalService.java`
  - Java class that represents an Android framework service talking to the HAL

There is no Android build system here on purpose. The code is small and self‑contained so you can read it directly and compile pieces if you want.

---

## C++ HAL and V4L2‑style abstraction

The C++ side is in [`AndroidHal.h`](file:///Users/vedang/AndroidHAL/cpp/AndroidHal.h) and [`AndroidHal.cpp`](file:///Users/vedang/AndroidHAL/cpp/AndroidHal.cpp).

### Frame type

`Frame` represents a camera frame in a very simple way:

- `width`, `height`: resolution
- `data`: one byte per pixel, stored in a flat `std::vector<std::uint8_t>`

This mirrors how a V4L2 driver would expose raw frame buffers, but without any hardware or kernel interaction.

### Device interfaces

The HAL talks to abstract devices instead of real hardware:

- `IV4L2Device`
  - `open(const std::string& node)`
  - `captureFrame() -> Frame`
- `IAudioDevice`
  - `open(const std::string& device)`
  - `readLevel() -> float`

These play the same role that real V4L2 and ALSA devices play in Android:

- In a real HAL you would wrap `/dev/video*` and ALSA or TinyAlsa APIs
- In this simulator they are pure C++ interfaces with a mock implementation

### Mock devices

`MockV4L2Device` and `MockAudioDevice` implement the interfaces without using real hardware:

- `MockV4L2Device`
  - `open(node)` records the node string and marks the device as opened
  - `captureFrame()` returns a 640×480 frame with a simple gradient pattern
- `MockAudioDevice`
  - `open(device)` records the device string and marks the device as opened
  - `readLevel()` returns a floating‑point value that slowly moves between 0.1 and 1.0

This is enough to simulate camera and audio behavior without touching the OS.

### AndroidHal facade

`AndroidHal` is the façade that a framework or Binder stub would talk to:

- Constructor receives references to `IV4L2Device` and `IAudioDevice`
- `openCamera(node)` and `captureFrame()`
- `openAudio(device)` and `readAudioLevel()`

The class tracks whether each device has been opened and returns empty or zero values if you call capture/read before open. This mimics the basic lifecycle checks you would normally implement in an Android HAL module.

---

## JNI bridge and Java framework class

The boundary between Java and C++ is implemented with JNI.

### Java side: framework‑like service

[`HalService`](file:///Users/vedang/AndroidHAL/java/com/example/androidhal/HalService.java) is a tiny Java class that looks like a framework service:

- Loads the native library:
  - `System.loadLibrary("androidhal_sim")`
- Declares native methods:
  - `nativeOpenCamera(String node)`
  - `nativeCaptureFrame()`
  - `nativeOpenAudio(String device)`
  - `nativeReadAudioLevel()`
- Exposes simple Java methods that delegate to the native ones

In real Android you would expose similar methods through a Binder interface generated by AIDL or HIDL. Here we skip Binder and call JNI directly to keep things small.

### C++ side: JNI glue

[`JniBridge.cpp`](file:///Users/vedang/AndroidHAL/cpp/JniBridge.cpp) implements the native methods:

- Creates one global `AndroidHal` instance:
  - Uses `MockV4L2Device` and `MockAudioDevice`
- Implements four JNI functions whose names match the Java native methods:
  - `Java_com_example_androidhal_HalService_nativeOpenCamera`
  - `Java_com_example_androidhal_HalService_nativeCaptureFrame`
  - `Java_com_example_androidhal_HalService_nativeOpenAudio`
  - `Java_com_example_androidhal_HalService_nativeReadAudioLevel`

Each JNI function:

- Converts Java types to C++ types (`jstring` to `std::string`, `jbyteArray` from `std::vector<std::uint8_t>`)
- Calls the corresponding `AndroidHal` method
- Converts the result back to Java types

This is the same pattern used in Android when the framework talks to a HAL module through JNI.

---

## How this maps to HIDL/AIDL and Binder

This simulator does not pull in real HIDL, AIDL or Binder classes. Instead it mirrors the layers conceptually:

- AIDL/HIDL interface
  - In real Android, describes IPC methods and generates stubs/proxies
  - In this simulator, the Java `HalService` interface plus the JNI functions represent this boundary
- Binder IPC
  - In real Android, delivers method calls across processes
  - In this simulator, you can think of the call from Java to JNI to `AndroidHal` as the IPC hop
- HAL module implementation
  - In real Android, implements camera/audio HAL interfaces and talks to kernel drivers
  - In this simulator, `AndroidHal` plus `MockV4L2Device` and `MockAudioDevice` play that role
- V4L2 and ALSA
  - In real Android, use kernel and TinyAlsa APIs
  - In this simulator, the device interfaces and mock implementations simulate those drivers

The structure is the same even though the code is much smaller and runs outside AOSP.

---

## How this matches the resume points

> Built a custom Android HAL module in C++ simulating camera/audio sensor interfaces per AOSP HIDL/AIDL conventions

- C++ HAL is represented by `AndroidHal`
- Camera and audio are modeled by `IV4L2Device`, `IAudioDevice`, and their mock implementations
- The public methods on `AndroidHal` are the operations that a HIDL/AIDL interface would expose

> Integrated V4L2 driver abstraction layer and bridged Java Android Framework to C++ HAL via JNI

- V4L2‑style abstraction:
  - `Frame` type
  - `IV4L2Device` interface and `MockV4L2Device` implementation
- Java–C++ bridge:
  - `HalService` Java class
  - `JniBridge.cpp` JNI functions that talk to `AndroidHal`

> Debugged IPC issues using Android Binder mechanism; reduced integration defects by 50% via custom test harness on Linux

- Binder is not implemented directly here, but:
  - The Java–JNI–HAL steps mirror a Binder call sequence
  - You could layer a test harness on top of `HalService` or directly on `AndroidHal` to simulate integration and IPC checks

> Validated AudioFlinger and TinyAlsa integration paths for audio HAL compliance

- Audio side is represented by `IAudioDevice`, `MockAudioDevice` and `AndroidHal::readAudioLevel`
- A real implementation would replace `MockAudioDevice` with a TinyAlsa‑backed implementation while keeping the same `IAudioDevice` interface

---

## Optional: how you could compile pieces locally

This repository does not include a full build system, but you can experiment if you have a C++ compiler and a JDK installed.

### Compile the pure C++ HAL only

From the repository root:

```bash
cd cpp
clang++ -std=c++17 -c AndroidHal.cpp
```

This only checks that the HAL code compiles; it does not build JNI or run anything.

### Compile Java class only

From the repository root:

```bash
cd java
javac com/example/androidhal/HalService.java
```

This checks that the Java side compiles. Building a full JNI shared library requires configuring include paths to `jni.h`, which depends on your local JDK installation and platform, so it is left out to keep the example minimal.

---

## How to read this project to learn the concepts

If you want to understand Android HAL patterns from this mini project:

1. Start with [`AndroidHal.h`](file:///Users/vedang/AndroidHAL/cpp/AndroidHal.h)
   - Understand the `Frame` type and the device interfaces
2. Read [`AndroidHal.cpp`](file:///Users/vedang/AndroidHAL/cpp/AndroidHal.cpp)
   - See how the mock devices generate data and how `AndroidHal` orchestrates them
3. Look at [`HalService.java`](file:///Users/vedang/AndroidHAL/java/com/example/androidhal/HalService.java)
   - See how a small Java API describes the operations available to the framework
4. Finally, read [`JniBridge.cpp`](file:///Users/vedang/AndroidHAL/cpp/JniBridge.cpp)
   - Map each Java method to its native implementation
   - Notice how data moves between Java and C++

Together these files give you a compact, readable example you can talk through in an interview to explain how you built and validated an Android HAL‑style module.

to run :

cd /Users/vedang/AndroidHAL/cpp
clang++ -std=c++17 HalDemo.cpp AndroidHal.cpp -o hal_demo
./hal_demo
